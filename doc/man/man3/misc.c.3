.TH "misc.c" 3 "Sat Jun 6 2015" "Version 0.1" "ldpsiz" \" -*- nroff -*-
.ad l
.nh
.SH NAME
misc.c \- 
.PP
Miscellaneous functions\&. 
.PP
\fBCopyright:\fP
.RS 4
Copyright (c) 2014, Alan R\&. Rogers <rogers@anthro.utah.edu>\&. This file is released under the Internet Systems Consortium License, which can be found in file 'LICENSE'\&. 
.RE
.PP
 

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdarg\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <ctype\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <gsl/gsl_matrix\&.h>\fP
.br
\fC#include <gsl/gsl_blas\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <execinfo\&.h>\fP
.br
\fC#include 'misc\&.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBccmp\fP(a, b)   ((a) == (b) ? 0 : ((a) > (b) ? 1 : -1))"
.br
.RI "\fIOlder C compilers lack strcasecmp, which compares strings ignoring case\&. \fP"
.ti -1c
.RI "#define \fBCALLSTACK_SIZE\fP   128"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "long \fBLInt_div_round\fP (long num, long denom)"
.br
.ti -1c
.RI "int \fBisopt\fP (const char *shortOpt, const char *longOpt, const char *arg)"
.br
.RI "\fIReturn 1 if string arg matches either shortOpt or longOpt\&. \fP"
.ti -1c
.RI "void \fBtellopt\fP (const char *opt, const char *description)"
.br
.ti -1c
.RI "char * \fBstrlowercase\fP (char *s)"
.br
.RI "\fIConvert NULL-terminated string to lower case\&. \fP"
.ti -1c
.RI "int \fBmystrcasecmp\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "void \fBcheckmem\fP (void *obj, const char *file, int line)"
.br
.ti -1c
.RI "void \fBassertFiniteArray\fP (const double *x, size_t dim, const char *file, int line)"
.br
.ti -1c
.RI "void \fBprintsqrmat\fP (const char *msg, unsigned dim, double m[][dim])"
.br
.ti -1c
.RI "void \fBprintgslmat\fP (const char *msg, size_t dim, gsl_matrix *m)"
.br
.ti -1c
.RI "int \fBmatIsFinite\fP (unsigned dim, double m[][dim])"
.br
.ti -1c
.RI "double \fBgetreldiff\fP (int dim, double x[], double y[], int verbose)"
.br
.ti -1c
.RI "char * \fBstrcenter\fP (const char *text, unsigned width, char *buff, unsigned buffsize)"
.br
.RI "\fICenter string 'text' in a field of width 'width'\&. \fP"
.ti -1c
.RI "int \fBgetNumCores\fP (void)"
.br
.ti -1c
.RI "long \fBlong_first_geq\fP (long val, long *v, long len)"
.br
.ti -1c
.RI "long \fBlong_last_leq\fP (long val, long *v, long len)"
.br
.ti -1c
.RI "void \fBdie\fP (const char *msg, const char *file, int line)"
.br
.ti -1c
.RI "void \fBeprintf\fP (const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "void * \fBmemdup\fP (const void *p, size_t n)"
.br
.ti -1c
.RI "int \fBstrCountSetChunks\fP (const char *str, const char *sep)"
.br
.ti -1c
.RI "int \fBstrcomment\fP (const char *s)"
.br
.RI "\fIReturn true if the first non-white char in string s is '#'; false otherwise\&. \fP"
.ti -1c
.RI "char * \fBstripComment\fP (char *s)"
.br
.RI "\fIstrip comment ('#' to eol) from a string \fP"
.ti -1c
.RI "int \fBstrempty\fP (const char *s)"
.br
.RI "\fIReturn true if string contains only whitespace; false otherwise\&. \fP"
.ti -1c
.RI "int \fBdblEquals\fP (double x, double y)"
.br
.RI "\fITest equality of x and y\&. \fP"
.ti -1c
.RI "void \fBdostacktrace\fP (const char *file, int line, FILE *ofp)"
.br
.ti -1c
.RI "double \fBreflect\fP (double x, double lo, double hi)"
.br
.RI "\fIFold x back and forth across the boundaries 'lo' and 'hi' to obtain a value y such that lo <= y <= hi\&. \fP"
.ti -1c
.RI "void \fBreplaceSuffix\fP (char *str, size_t str_size, const char *suffix, size_t suffix_len)"
.br
.RI "\fIReplace suffix (part after last period) of string 'str' with new suffix\&. \fP"
.ti -1c
.RI "void \fBunitTstResult\fP (const char *facility, const char *result)"
.br
.ti -1c
.RI "int \fBcompareLongs\fP (const void *void_x, const void *void_y)"
.br
.RI "\fICompare two long ints\&. \fP"
.ti -1c
.RI "int \fBcompareDoubles\fP (const void *void_x, const void *void_y)"
.br
.RI "\fICompare two doubles\&. \fP"
.ti -1c
.RI "int \fBpr_gsl_vector\fP (FILE *fp, const char *fmt, const gsl_vector *v)"
.br
.ti -1c
.RI "unsigned \fBhash\fP (const char *ss)"
.br
.RI "\fIHash a character string\&. Used for generating unique file names\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Miscellaneous functions\&. 
.PP
\fBCopyright:\fP
.RS 4
Copyright (c) 2014, Alan R\&. Rogers <rogers@anthro.utah.edu>\&. This file is released under the Internet Systems Consortium License, which can be found in file 'LICENSE'\&. 
.RE
.PP


\fBAuthor:\fP
.RS 4
Alan R\&. Rogers 
.RE
.PP

.SH "Define Documentation"
.PP 
.SS "#define \fBccmp\fP(a, b)   ((a) == (b) ? 0 : ((a) > (b) ? 1 : -1))"
.PP
Older C compilers lack strcasecmp, which compares strings ignoring case\&. For portability, I provide this here under a different name\&. 
.SH "Function Documentation"
.PP 
.SS "int \fBcompareDoubles\fP (const void *void_x, const void *void_y)"
.PP
Compare two doubles\&. Function interprets its arguments as pointers to doubles\&.
.PP
\fBParameters:\fP
.RS 4
\fIvoid_x,void_y\fP Pointers to the two doubles, cast as pointers to voids\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1, 0, or 1 depending on whether the first arg is <, ==, or > the second\&. 
.RE
.PP

.PP
Referenced by confidenceBounds()\&.
.SS "int \fBcompareLongs\fP (const void *void_x, const void *void_y)"
.PP
Compare two long ints\&. Function interprets its arguments as pointers to long ints\&.
.PP
\fBParameters:\fP
.RS 4
\fIvoid_x,void_y\fP Pointers to the two integers, cast as pointers to voids\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1, 0, or 1 depending on whether the first arg is <, ==, or > the second\&. 
.RE
.PP

.PP
Referenced by Boot_new()\&.
.SS "int \fBdblEquals\fP (doublex, doubley)"
.PP
Test equality of x and y\&. In this test NaN == NaN, Inf == Inf, and -Inf == -Inf\&. 
.SS "int \fBisopt\fP (const char *shortOpt, const char *longOpt, const char *arg)"
.PP
Return 1 if string arg matches either shortOpt or longOpt\&. ShortOpt and longOpt are ignored if their values are NULL\&. If arg doesn't match either shortOpt or longOpt, then return 0\&. 
.SS "void \fBreplaceSuffix\fP (char *str, size_tstr_size, const char *suffix, size_tsuffix_len)"
.PP
Replace suffix (part after last period) of string 'str' with new suffix\&. If original string has no suffix, then append one to string\&. Abort if string isn't long enough\&. 
.SS "char* \fBstrcenter\fP (const char *text, unsignedwidth, char *buff, unsignedbuffsize)"
.PP
Center string 'text' in a field of width 'width'\&. The centered string is written into the character string 'buff', whose size is 'buffsize'\&. 
.SS "int \fBstrempty\fP (const char *s)"
.PP
Return true if string contains only whitespace; false otherwise\&. 
.PP
Referenced by Ini_new(), and read_data()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ldpsiz from the source code\&.
