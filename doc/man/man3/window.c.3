.TH "window.c" 3 "Thu May 29 2014" "Version 0.1" "ldpsiz" \" -*- nroff -*-
.ad l
.nh
.SH NAME
window.c \- 
.PP
A window that slides across the chromosome\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <float\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include 'window\&.h'\fP
.br
\fC#include 'readgtp\&.h'\fP
.br
\fC#include 'misc\&.h'\fP
.br
\fC#include 'tabulation\&.h'\fP
.br
\fC#include 'boot\&.h'\fP
.br
\fC#include 'sums\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBSNPstore\fP"
.br
.RI "\fI\fBSNPstore\fP is a place to store objects of type \fBSNP\fP when they are not in use\&. \fP"
.ti -1c
.RI "struct \fBWindow\fP"
.br
.RI "\fI\fBWindow\fP represents a window that slides across the chromosome\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBSNP_getDsq_haploid\fP (double *pqpq, \fBSNP\fP *x, \fBSNP\fP *y)"
.br
.RI "\fICalculate D squared from pair of haploid SNPs\&. \fP"
.ti -1c
.RI "void \fBSNP_clear\fP (\fBSNP\fP *snp)"
.br
.RI "\fISet values to initial states\&. \fP"
.ti -1c
.RI "void \fBSNP_free\fP (\fBSNP\fP *snp)"
.br
.RI "\fIfree linked list of SNPs \fP"
.ti -1c
.RI "\fBSNP\fP * \fBSNP_new\fP (unsigned nGtype, int bootreps)"
.br
.RI "\fIAllocate a new \fBSNP\fP, including the arrays used to store genotype data and bootstrap multiplicity values\&. \fP"
.ti -1c
.RI "int \fBSNP_set\fP (\fBSNP\fP *snp, long ndx, double mappos, const unsigned char *gtype, const \fBBoot\fP *boot, unsigned ploidy)"
.br
.RI "\fIInitialize a \fBSNP\fP using the data given by the other parameters\&. \fP"
.ti -1c
.RI "void \fBSNP_show\fP (\fBSNP\fP *snp, FILE *fp)"
.br
.RI "\fIPrint \fBSNP\fP\&. \fP"
.ti -1c
.RI "int \fBSNP_count\fP (\fBSNP\fP *snp)"
.br
.RI "\fICount SNPs in linked list\&. \fP"
.ti -1c
.RI "double \fBSNP_mappos\fP (const \fBSNP\fP *snp)"
.br
.ti -1c
.RI "\fBSNP\fP * \fBSNP_connect\fP (\fBSNP\fP *list1, \fBSNP\fP *list2)"
.br
.RI "\fIConnect list2 to the tail of list1 and return a pointer to list1\&. \fP"
.ti -1c
.RI "double \fBSNP_getDsq\fP (double *pqpq, \fBSNP\fP *x, \fBSNP\fP *y, unsigned ploidy)"
.br
.RI "\fICalculate D squared\&. \fP"
.ti -1c
.RI "long \fBSNP_ndx\fP (const \fBSNP\fP *snp)"
.br
.RI "\fIindex of this \fBSNP\fP (begins with 0) \fP"
.ti -1c
.RI "int \fBSNP_nGtype\fP (const \fBSNP\fP *snp)"
.br
.RI "\fINumber of genotypes sampled for this \fBSNP\fP\&. \fP"
.ti -1c
.RI "\fBSNPstore\fP * \fBSNPstore_new\fP (unsigned nGtype, int bootreps)"
.br
.RI "\fIAllocate a new object of type \fBSNPstore\fP\&. \fP"
.ti -1c
.RI "void \fBSNPstore_free\fP (\fBSNPstore\fP *store)"
.br
.RI "\fIFree an object of type \fBSNPstore\fP\&. \fP"
.ti -1c
.RI "\fBSNP\fP * \fBSNPstore_checkout\fP (\fBSNPstore\fP *store)"
.br
.RI "\fIObtain a \fBSNP\fP from the store, allocating if necessary\&. \fP"
.ti -1c
.RI "void \fBSNPstore_checkin\fP (\fBSNPstore\fP *store, \fBSNP\fP *snp)"
.br
.RI "\fICheck a \fBSNP\fP back into the store\&. \fP"
.ti -1c
.RI "\fBWindow\fP * \fBWindow_new\fP (double width_cm, FILE *ifp, long int sampling_interval, unsigned ploidy)"
.br
.RI "\fIAllocate a new \fBWindow\fP\&. \fP"
.ti -1c
.RI "void \fBWindow_free\fP (\fBWindow\fP *window)"
.br
.RI "\fIFree a \fBWindow\fP\&. \fP"
.ti -1c
.RI "\fBSNP\fP * \fBWindow_currSNP\fP (\fBWindow\fP *window)"
.br
.RI "\fIReturn pointer to current focal \fBSNP\fP\&. \fP"
.ti -1c
.RI "int \fBWindow_nextSNP\fP (\fBWindow\fP *window, \fBBoot\fP *boot)"
.br
.RI "\fIGet next \fBSNP\fP from input file and link it into the linked list pointed to by window->curr\&. \fP"
.ti -1c
.RI "int \fBWindow_advance\fP (\fBWindow\fP *window, \fBTabulation\fP *tab, \fBBoot\fP *boot, long count)"
.br
.RI "\fIAdd a new \fBSNP\fP to the window\&. \fP"
.ti -1c
.RI "unsigned \fBWindow_nGtype\fP (const \fBWindow\fP *window)"
.br
.RI "\fIReturn current value of window->nGtype\&. \fP"
.ti -1c
.RI "long \fBWindow_nSNPsRead\fP (const \fBWindow\fP *window)"
.br
.RI "\fIReturn the number of SNPs that have been read\&. \fP"
.ti -1c
.RI "void \fBWindow_test\fP (int verbose)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A window that slides across the chromosome\&. 


.PP
\fBAuthor:\fP
.RS 4
Alan R\&. Rogers LD is calculated from pairs of sites within a window, which slides across the chromosome\&. This file implements \fBWindow\fP, which represents that sliding window\&.
.RE
.PP
\fBCopyright:\fP
.RS 4
Copyright (c) 2014, Alan R\&. Rogers rogers@anthro.utah.edu\&. This file is released under the Internet Systems Consortium License, which can be found in file 'LICENSE'\&. 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void SNP_clear (\fBSNP\fP *snp)"

.PP
Set values to initial states\&. This function does not initialize snp->prev, because doing so risks a memory leak\&. 
.PP
Referenced by SNP_new(), and SNPstore_checkout()\&.
.SS "\fBSNP\fP* SNP_connect (\fBSNP\fP *list1, \fBSNP\fP *list2)"

.PP
Connect list2 to the tail of list1 and return a pointer to list1\&. Usage: list1 = SNP_connect(list1, list2)
.PP
\fBParameters:\fP
.RS 4
\fIlist1,list2\fP Linked lists of SNPs, which will be concatenated\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the head of the combined list\&. If list1 is nonNULL, this returned pointer will equal 'list1'\&. Otherwise, it will equal 'list2'\&. Either way, the returned value is the head of a list that contains all the entries in list 1 followed by all the entries in list 2\&. 
.RE
.PP

.PP
Referenced by SNPstore_checkin()\&.
.SS "double SNP_getDsq (double *pqpq, \fBSNP\fP *x, \fBSNP\fP *y, unsignedploidy)"

.PP
Calculate D squared\&. Use two SNPs to calculate D*D (where D is the standard LD coefficient) and the product of the pq values at the two SNPs\&. Function also sets the value of *pqpq\&. This version uses the EM algorithm to get a maximum-likelihood estimate of D\&. This also provides a ML estimate of Dsq=D*D because of the invariant property of ML estimates\&. 
.PP
References DsqData_print(), DsqData::hiD, hiD(), DsqData::loD, loD(), MAKE_PHASED, minimize1D(), DsqData::nGam, DsqData::nUnphased, DsqData::px, DsqData::py, DsqData::tol, trBits(), and UNPHASED_PAIR\&.
.PP
Referenced by Window_advance()\&.
.SS "double SNP_getDsq_haploid (double *pqpq, \fBSNP\fP *x, \fBSNP\fP *y)"

.PP
Calculate D squared from pair of haploid SNPs\&. Use two SNPs to calculate D*D (where D is the standard LD coefficient)\&. Also calculates the product of the pq values at the two SNPs\&. Function returns the value of D*D and sets the value of *pqpq\&. This version is for haploid genotypes, with each genotype equal either to 0 or 1\&. 
.SS "\fBSNP\fP* SNP_new (unsignednGtype, intbootreps)"

.PP
Allocate a new \fBSNP\fP, including the arrays used to store genotype data and bootstrap multiplicity values\&. In order to improve efficiency, these allocations are all done with a single call to malloc\&. That way, data for each \fBSNP\fP is in contiguous memory, and we minimize cache misses\&.
.PP
\fBParameters:\fP
.RS 4
\fInGtype\fP Number of genotypes at each \fBSNP\fP 
.br
\fIbootreps\fP Number of bootstrap replicates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to newly-allocated \fBSNP\fP\&. 
.RE
.PP

.PP
References SNP_clear()\&.
.PP
Referenced by SNPstore_checkout()\&.
.SS "int SNP_set (\fBSNP\fP *snp, longndx, doublemappos, const unsigned char *gtype, const \fBBoot\fP *boot, unsignedploidy)"

.PP
Initialize a \fBSNP\fP using the data given by the other parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIndx\fP SNPs are indexed (numbered) starting with 0\&. ndx is the index of the current \fBSNP\fP\&.
.br
\fImappos\fP position of \fBSNP\fP in units of the recombinational map\&.
.br
\fIgtype\fP points to a character string representing genotypes
.br
\fIboot\fP points to \fBBoot\fP structure, which is used to store information about bootstrap replicates\&.
.br
\fIploidy\fP (either 0 or 1)
.RE
.PP
\fBReturns:\fP
.RS 4
1 if the \fBSNP\fP is polymorphic, or 0 if monomorphic\&. 
.RE
.PP

.PP
Referenced by Window_nextSNP()\&.
.SS "void SNPstore_checkin (\fBSNPstore\fP *store, \fBSNP\fP *snp)"

.PP
Check a \fBSNP\fP back into the store\&. 
.PP
References SNPstore::head, and SNP_connect()\&.
.PP
Referenced by Window_advance()\&.
.SS "\fBSNP\fP* SNPstore_checkout (\fBSNPstore\fP *store)"

.PP
Obtain a \fBSNP\fP from the store, allocating if necessary\&. 
.PP
References SNPstore::bootreps, SNPstore::head, SNPstore::nGtype, SNP_clear(), and SNP_new()\&.
.PP
Referenced by Window_nextSNP()\&.
.SS "\fBSNPstore\fP* SNPstore_new (unsignednGtype, intbootreps)"

.PP
Allocate a new object of type \fBSNPstore\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fInGtype\fP number of genotypes 
.br
\fIbootreps\fP number of bootstrap replicates 
.RE
.PP

.PP
References SNPstore::bootreps, SNPstore::head, and SNPstore::nGtype\&.
.PP
Referenced by Window_nextSNP()\&.
.SS "int Window_advance (\fBWindow\fP *window, \fBTabulation\fP *tab, \fBBoot\fP *boot, longcount)"

.PP
Add a new \fBSNP\fP to the window\&. 
.PP
References Window::curr, Dbl_near(), Window::ploidy, Window::sampling_interval, SNP_getDsq(), SNPstore_checkin(), Window::store, Window::width_cm, and Window_nextSNP()\&.
.PP
Referenced by threadfun()\&.
.SS "\fBWindow\fP* Window_new (doublewidth_cm, FILE *ifp, long intsampling_interval, unsignedploidy)"

.PP
Allocate a new \fBWindow\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwidth_cm\fP width of \fBWindow\fP in centimorgans
.br
\fIsampling_interval\fP If sampling_interval is 2, window will skip every other \fBSNP\fP\&. This makes things fast for debugging\&.
.br
\fIploidy\fP 1 for haploid, 2 for diploid 
.RE
.PP

.PP
References Window::curr, Window::ifp, Window::nGtype, Window::nSNPs, Window::ploidy, Window::sampling_interval, Window::store, and Window::width_cm\&.
.PP
Referenced by threadfun()\&.
.SS "int Window_nextSNP (\fBWindow\fP *window, \fBBoot\fP *boot)"

.PP
Get next \fBSNP\fP from input file and link it into the linked list pointed to by window->curr\&. Return 0 on success, EOF if end of file is reached, and 1 on any other error\&. 
.PP
References Window::curr, Dbl_near(), Gtp_readSNP(), Window::gtype, Window::ifp, Window::nGtype, Window::nSNPs, Window::ploidy, SNP_set(), SNPstore_checkout(), SNPstore_new(), and Window::store\&.
.PP
Referenced by threadfun(), and Window_advance()\&.
.SS "long Window_nSNPsRead (const \fBWindow\fP *window)"

.PP
Return the number of SNPs that have been read\&. 
.PP
References Window::nSNPs\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ldpsiz from the source code\&.
